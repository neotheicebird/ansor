{"name":"Ansor","tagline":"Compilation of cool SO (StackOverflow) ansors (read: answers) to awesome python questions and a byte of knowledge cookie I got.","body":"### Welcome to AnSOr.\r\n\r\nHere I am collecting awesome ansors (read: answers) found in [SO](http://stackoverflow.com) to great (mostly python related) questions. Here they are:\r\n\r\n# [1 Late binding](http://stackoverflow.com/a/27636966/2200571)\r\n\r\n    fns = []\r\n    for i in range(5):\r\n        def fn(x):\r\n            return x + i\r\n        fns.append(fn)\r\n    \r\n    # Passing a 1 to each function in the list I would expect an output of [1, 2, 3, 4, 5].\r\n    print [f(1) for f in fns]    # prints [5, 5, 5, 5, 5]\r\n\r\nThe point to understand here is that python uses a late binding approach and the function call takes place at runtime. So, Murphy's law. This is how it is fixed:\r\n\r\n    for i in range(5):\r\n        def fn(x, i=i):  # <-----\r\n            return x + i\r\n        fns.append(fn)\r\n\r\n    print [f(1) for f in fns]    # prints [1, 2, 3, 4, 5]\r\n\r\nWhy is this working this way? The answer is in the closure of the environment they're defined in. That is scope of a variable or which namespace python would search for the variable when it is executed. So in the first case `i` is global, but in the second one by using a default `i` the value of `i` is made local to the function. [more so](http://stackoverflow.com/questions/233673/lexical-closures-in-python)\r\n\r\nIs there a more pythonic way to do this. There sure are many:\r\n\r\n    fns = []\r\n\r\n    for i in xrange(5):\r\n        def fn(j):\r\n            def inner(x): return x * j\r\n            return inner\r\n        fns.append(fn(i))\r\n\r\n    print [f(1) for f in fns]    # prints [1, 2, 3, 4, 5]\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}